<!DOCTYPE html>
<head>

<meta charset="utf-8">
<title>ðŸ¦… SSA Globe Data Plots</title>  <!-- added -->
<style>
body, html {
  font-family: arial;
}
.map {
  float: left;
  padding: 5px;
  border: solid 0px #eee; /* change 1px into 0px */
  border-radius: 5px;
}
.map .title {
  float: right;
}
.graticule {
  fill: none;
  stroke: #777;
  stroke-width: .5px;
  stroke-opacity: .7;  /* original .5 */
  pointer-events: all;
}
.land {
  fill: none;
  stroke: #000;
  stroke-width: 1;
}
.contour-stroke {
  stroke: #000;
  stroke-width: 0.5;
  stroke-linejoin: round;
}
.legend {               /* added */
  float: left;          /* added */
  padding: 0px;         /* added */
  border-radius: 5px;   /* added */
  position: relative;   /* added */
  left: 10px;           /* added */
}
.legend .title {        /* added */
  float: right;         /* added */
}                       /* added */
</style>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/topojson.v1.min.js"></script> 
<script src="../js/netcdfjs.js"></script>
<script src="../js/numjs.js"></script>
<script src="../js/d3-contour@1"></script>
<script src="../js/d3-color@1"></script>
<script src="../js/d3-geo@1"></script>
<script src="../js/d3-geo-projection@2"></script>
<script src="../js/versor@0"></script>
<script src="../js/d3-legend.min.js"></script>  <!-- added -->
<script src="../js/topojson@3"></script>        <!-- added -->
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>  <!-- added -->
</head>

<body>

<p>Synchronized maps :: TEC Data from Madrigal Database</p>

<iframe
    src="./datadir_madgps/README.txt"
    frameBorder="0"
    class=""
    scrolling="auto"
    height="44"
    width="500">
</iframe>


</br>
<input id="pi_input" type="range" min="0" max="287" step="1">
<p>Slide Dial Value = <output id="valueN"></output></p>
<p>Time = <output id="valueT"></output></p>
<p>Corresponding File: <output id="valueFILE"></output></p>


<p>
<div class="map">
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</div>
<div id="map1" class="map">
	<div class="title">TEC</div>   <!-- changed --> <!-- TEC unit is TECU = 10^16 m^-2 -->
</div>
<div id="legend1" class="legend">   <!-- added -->
     <div class="title">TECU</div>  <!-- added -->
</div>                              <!-- added -->

<div id="map2" class="map">
	<div class="title">TECP</div>   <!-- changed --> <!-- TECP unit is TECU = 10^16 m^-2 -->
</div>
<div id="legend2" class="legend">   <!-- added -->
     <div class="title">TECU</div>  <!-- added -->
</div>                              <!-- added -->


<script>

//=============== LISTEN TO SLIDER RANGE INPUT ===============
const value = document.querySelector("#value");
const input = document.querySelector("#pi_input");
var hhval = "23"
var mmval = "05"
valueN.textContent = input.value;
valueT.textContent = hhval + ":" + mmval + " UTC";
valueFILE.textContent = "madgps_" + hhval + mmval + ".nc";

input.addEventListener("input", (event) => {
  let hrdec = 5*event.target.value/60;
  let hhval = Math.floor(hrdec);
  let mmval = Math.round((hrdec - hhval)*60);
  if (hhval < 10) {hhval = "0" + hhval;}
  if (mmval < 10) {mmval = "0" + mmval;}
  valueT.textContent = hhval + ":" + mmval + " UTC";
  valueFILE.textContent = "madgps_" + hhval + mmval + ".nc";
  valueN.textContent = event.target.value;
  MyMainFun(hhval, mmval);
});

var hhmmval = document.getElementById("valueT").value;
var hhval = hhmmval.substr(0, 2);
var mmval = hhmmval.substr(3, 2);
console.log(hhmmval)
console.log(hhval)
console.log(mmval)



//--------------------------------------
function zoomed() {
  var transform = d3.event.transform;
  projection.scale(scale * transform.k);
  updatePaths(svg);
}

//--------------------------------------
function dragstarted() {
  v0 = versor.cartesian(projection.invert(d3.mouse(this)));
  r0 = projection.rotate();
  q0 = versor(r0);
}

//--------------------------------------
function dragged(d) {
  var v1 = versor.cartesian(projection.rotate(r0).invert(d3.mouse(this))),
      q1 = versor.multiply(q0, versor.delta(v0, v1)),
      r1 = versor.rotation(q1);
  projection.rotate(r1);
  updatePaths(svg);
}

//--------------------------------------
function updatePaths(svg) {
  svg.forEach(function(e) {
     	e.selectAll('path.contours').attr("d", geoPath);
     	e.selectAll('path.graticule').attr('d', geoPath);
     	e.selectAll('path.land').attr('d', geoPath);
  });
}

//--------------------------------------
function createMap(id, values, range, colorscheme) {   // modified

  s = d3.select(id).select("svg").selectAll("path").remove(); // this was added (remove all "svg paths" before removing the "svg")
  s = null;                                                   // this was added

  s = d3.select(id).select("svg").remove(); // this was added (since all "svg paths" have been removed, we can now remove the "svg")
  s = null;                                 // this was added
    
  var svg = d3.select('body').select(id).append('svg')
    .attr('width', width)
    .attr('height', height);

  var group = svg.append("g").datum([]);

  var color = d3.scaleSequential(colorscheme)             // https://d3js.org/d3-scale-chromatic
      .domain(range);

  //var color = d3.scaleSequential(d3.interpolatePlasma)  // https://d3js.org/d3-scale-chromatic
  //    .domain(d3.extent(values));

  //console.log(d3.extent(values));
  // interpolatePlasma
  // interpolateMagma
  // interpolateInferno
  // interpolateViridis
  // interpolateWarm
  // interpolateCool
  // interpolateCubehelixDefault

  var contours = d3.contours()
      .smooth(false) // originally true
      .size([isize, jsize]);

  group
   //.attr("class", "contour-stroke")
   .selectAll("path")
   .data(contours(values).map(invert))
   .enter().append("path")
   .attr('class', 'contours')
   .attr("fill", function(d) {if (d.value < -8.8){return "#F0F0F0";} else {return color(d.value);} })  // CHANGE d.value < 0 INTO d.value < -8.8 TO ACCOMODATE MIXTURE OF TEC & TECP    
   //.attr("fill", function(d) { return color(d.value); })
   .attr("d", geoPath);

  group.append('path')
    .datum(graticule)
    .attr('class', 'graticule')
    .attr('d', geoPath);

  group.append("path")
      .datum(world)
      .attr("class", "land")
      .attr("d", geoPath);

  // zoom on svg; drag on group
  group.call(d3.drag().on('start', dragstarted)
		      .on('drag', dragged));
  svg.call(d3.zoom().on('zoom', zoomed));

  return svg;
}


//==========================================
function invert(d) {
    var shared = {};
    var p = {
      type: "Polygon",
      coordinates: d3.merge(d.coordinates.map(function(polygon) {
        return polygon.map(function(ring) {
          return ring.map(function(point) {
            return [point[0] / isize * 360 - 180, 90 - point[1] / jsize * 180];
          }).reverse();
        });
      }))
    };
    // Record the y-intersections with the antimeridian.
    p.coordinates.forEach(function(ring) {
      ring.forEach(function(p) {
        if (p[0] === -180 || p[0] === 180) {
                shared[p[1]] |= p[0] === -180 ? 1 : 2;
        }
      });
    });

    // Offset any unshared antimeridian points to prevent their stitching.
    p.coordinates.forEach(function(ring) {
      ring.forEach(function(p) {
        if ((p[0] === -180 || p[0] === 180) && shared[p[1]] !== 3) {
          p[0] = p[0] === -180 ? -179.9995 : 179.9995;
        }
      });
    });

    p = d3.geoStitch(p);

    // If the MultiPolygon is empty, treat it as the Sphere.
    return p.coordinates.length
        ? {type: "Polygon", coordinates: p.coordinates, value: d.value}
        : {type: "Sphere", value: d.value};
}

//==========================================
function reverseVar(values) {
    values = nj.array(values).reshape(jsize,isize);             //  a matrix with n rows and m columns, shape will be [n,m].
    values = values.slice([null, null, -1],null);
    values = values.flatten().tolist();

    return values;
}

//==========================================
var svg = [];
var world;
var graticule;

var width  = 900,    // size of square frame; original is 400
    height = 900,    // size of square frame; original is 400
    scale  = 450,    // size of the globe; original is 200
    origin = {x: 55, y: -40};

var v0, // Mouse position in Cartesian coordinates at start of drag gesture.
    r0, // Projection rotation as Euler angles at start.
    q0; // Projection rotation as versor at start.

var projection = d3.geoOrthographic()
    .scale(scale)
    .translate([width/2, height/2])
    .rotate([origin.x, origin.y])
    .center([0, 0]);
	
var geoPath = d3.geoPath()
    .projection(projection);

var min1 = 0;    // added
var max1 = 100;  // added
var delta1 = 5;  // added
var nbLevels1 = Math.abs(max1-min1)/delta1 + 1;  // added

var colorLEG1 = d3.scaleSequential(d3.interpolatePlasma)   // https://d3js.org/d3-scale-chromatic
      .domain([min1,max1]); // added
// interpolatePlasma
// interpolateMagma
// interpolateInferno
// interpolateViridis
// interpolateWarm
// interpolateCool
// interpolateCubehelixDefault

var min2 = -6;    // added
var max2 =  6;    // added
var delta2 = 0.5; // added
var nbLevels2 = Math.abs(max2-min2)/delta2 + 1;  // added

var colorLEG2 = d3.scaleSequential(d3.interpolatePuOr)   // https://d3js.org/d3-scale-chromatic
      .domain([min2,max2]); // added
// interpolatePlasma
// interpolateMagma
// interpolateInferno
// interpolateViridis
// interpolateWarm
// interpolateCool
// interpolateCubehelixDefault


//================================================================================
// urlpath was originally "navy_winds_2.nc" (UWND,VWND)
// changed into --> "etopo60_2.nc" (ROSE) -->  "wamipe_hhmm.nc" (TEC,NMF2,HMF2,FoF2)
// changed into --> "madgps_hhmm.nc" (TEC)
// netcdf data has to be arranged from longitude -180 to 180 !!!

//var urlpath = "./datadir_madgps/madgps_0035.nc" 
//var urlpath = "./datadir_madgps/madgps_" + hhval + mmval + ".nc"
//var urlpath = "./datadir_madgps/madgps_" + hh_in + mm_in + ".nc"

//================================================================================
var urlpath = "./datadir_madgps/madgps_" + hhval + mmval + ".nc"
var reader;
var isize, jsize;

//valueFILE.textContent = urlpath;

var oReq = new XMLHttpRequest();
oReq.open("GET", urlpath, true);
oReq.responseType = "blob";

oReq.onload = function(oEvent) {
  var blob = oReq.response;
  reader_url = new FileReader();
  
  reader_url.onload = function(e) {
  //====================================================================================
    reader = new netcdfjs(this.result);

    isize = reader.dimensions[0].size;
    jsize = reader.dimensions[1].size;

    var dim0Name = reader.dimensions[0].name;
    var dim1Name = reader.dimensions[1].name;
    axis0 = reader.getDataVariable(dim0Name);
    axis1 = reader.getDataVariable(dim1Name);

    var valuesVar1 = reader.getDataVariable('TEC');  // added
    valuesVar1 = reverseVar(valuesVar1);             // added
    var valuesVar2 = reader.getDataVariable('TECP'); // added
    valuesVar2 = reverseVar(valuesVar2);             // added

    range1 = [min1, max1]; // modified (for TEC)
    range2 = [min2, max2]; // modified (for TECP)

    d3.json("../world-110m.json", function(error, worldJSON) {
      if (error) throw error;
      world = topojson.feature(worldJSON, worldJSON.objects.land);
      graticule = d3.geoGraticule();
    
      svg1 = createMap("#map1", valuesVar1, range1, d3.interpolatePlasma); // modified
      svg.push(svg1);

      svg2 = createMap("#map2", valuesVar2, range2, d3.interpolatePuOr); // modified
      svg.push(svg2);

      svgLegend1 = d3.select("#legend1").append('svg') //
                           .attr('width', 90)          // original is 60
                           .attr('height', 800);       // original is 800
      svgLegend1.append("g").attr("class", "legendLinear1"); //
      var legendLinear1 = d3.legendColor()       //
                           .shapeWidth(30)       // original is 15
                           .shapeHeight(34.5)    // original is 15
                           .shapePadding(0)      // original is 1
                           .cells(nbLevels1)     //
                           .orient('vertical')   //
                           .ascending(true)      //
                           .labelAlign('start')  //
                           .scale(colorLEG1);    // 
      svgLegend1.select(".legendLinear1")        //
                        .call(legendLinear1);    //  

      svgLegend2 = d3.select("#legend2").append('svg') //
                           .attr('width', 90)          // original is 60
                           .attr('height', 800);       // original is 800
      svgLegend2.append("g").attr("class", "legendLinear2"); //
      var legendLinear2 = d3.legendColor()       //
                           .shapeWidth(30)       // original is 15
                           .shapeHeight(34.5)    // original is 15
                           .shapePadding(0)      // original is 1
                           .cells(nbLevels2)     //
                           .orient('vertical')   //
                           .ascending(true)      //
                           .labelAlign('start')  //
                           .scale(colorLEG2);    // 
      svgLegend2.select(".legendLinear2")        //
                        .call(legendLinear2);    //  
    
   });

  //====================================================================================
  }

  reader_url.readAsArrayBuffer(blob);

}

oReq.send(); //start process


//---------------------------------------------------------------------------------------------------
function MyMainFun(hh_in, mm_in) {

var urlpath = "./datadir_madgps/madgps_" + hh_in + mm_in + ".nc"
var reader;
var isize, jsize;

//valueFILE.textContent = urlpath;

var oReq = new XMLHttpRequest();
oReq.open("GET", urlpath, true);
oReq.responseType = "blob";

oReq.onload = function(oEvent) {
  var blob = oReq.response;
  reader_url = new FileReader();

  reader_url.onload = function(e) {
  //====================================================================================
    reader = new netcdfjs(this.result);

    isize = reader.dimensions[0].size;
    jsize = reader.dimensions[1].size;

    var dim0Name = reader.dimensions[0].name;
    var dim1Name = reader.dimensions[1].name;
    axis0 = reader.getDataVariable(dim0Name);
    axis1 = reader.getDataVariable(dim1Name);

    var valuesVar1 = reader.getDataVariable('TEC'); // added
    valuesVar1 = reverseVar(valuesVar1);            // added
    var valuesVar2 = reader.getDataVariable('TECP'); // added
    valuesVar2 = reverseVar(valuesVar2);             // added

    var range1 = [min1, max1]; // modified (for TEC)
    var range2 = [min2, max2]; // modified (for TECP)

    d3.json("../world-110m.json", function(error, worldJSON) {
      if (error) throw error;
    
      svg1 = createMap("#map1", valuesVar1, range1, d3.interpolatePlasma); // modified
      svg.push(svg1);

      svg2 = createMap("#map2", valuesVar2, range2, d3.interpolatePuOr); // modified  
      svg.push(svg2);
    
   });

  //====================================================================================
  }

  reader_url.readAsArrayBuffer(blob);
}

oReq.send(); //start process

//---------------------------------------------------------------------------------------------------
}

</script>

